syntax = "proto2";

package raft.v1;

message Log {
  required bytes value = 1;
  required uint64 term = 2;
}

message RequestVoteRequest {
  // The candidate's term.
  required uint64 term = 1;
  // The candidate requesting the vote.
  required uint64 candidate_id = 2;
  // Index of candidate's last log entry.
  //
  // Will be null when the candidate's log is empty.
  optional uint64 last_log_index = 3;
  // Term of candidate's last log entry.
  //
  // Will be null when the candidate's log is empty.
  optional uint64 last_log_term = 4;
}

message RequestVoteResponse {
  // The current term, for candidate to updat itself.
  required uint64 term = 1;
  // If the candidate received the vote.
  required bool vote_granted = 2;
}

message AppendEntriesRequest {
  // The cluster leader term.
  required uint64 term = 1;
  // The cluster leader id.
  required uint64 leader_id = 2;
  // Index of log entry immediately preceding new ones.
  //
  // Will be null when the leader's log is empty.
  optional uint64 previous_log_index = 3;
  // Term of log entry immediately preceding new ones.
  //
  // Will be null when the leader's log is empty.
  optional uint64 previous_log_term = 4;
  // Log entries to store.
  //
  // Will be empty when AppendEntries is used for heartbeats.
  repeated Log entries = 5;
  // The cluster leader commit index (index of highest log entry known to be committed).
  required uint64 leader_commit_index = 6;
}

message AppendEntriesResponse {
  // The current term of the follower, for leader to update itself.
  required uint64 term = 1;
  // True if follower contained entry matching previous_log_index and previous_log_term.
  required bool success = 2;
}

service Raft {
  // Invoked by candidates to start leader elections.
  rpc RequestVote(RequestVoteRequest) returns (RequestVoteResponse) {}
  // Invoke by the cluster leader to append new log entries to a follower.
  rpc AppendEntries(AppendEntriesRequest) returns (AppendEntriesResponse) {}
}
